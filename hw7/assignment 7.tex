\documentclass[a4paper,12pt]{article}
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage[noend] {algpseudocode}
\usepackage{fancyhdr}

\pagestyle{fancy}
\lhead{Algorithms and Data Structure 7}
\rhead{Drishti Maharjan}

\begin{document}
\title{Algorithms and Data Structures }
\author{Drishti Maharjan}
\maketitle

\section*{\center Assignment 7}
\newpage
\subsection*{Problem 7.1 \newline}
\subsubsection*{\textnormal{a. \textit{ Code in 7.1a.cpp stack.h} \newline
Time complexity analysis: \newline
void push(T x) $ = \theta(1) $ \newline
T pop() $ =  \theta (1) $ \newline
bool isEmpty() $ = \theta(1) $ \newline
Since all the operations don't depend on the size of the stack and takes constant time, all operations have constant time complexity.\newline \newline 
b. \textit{ Code in 7.1b.cpp Queue.h }\newline  }}

\subsection*{ Problem 7.2 }
\subsubsection*{\textnormal{a. To reverse a linked list in linear time, we can't use our regular recursive function. Instead, we can reverse the direction of the pointer using pointers next, prev, current. In the pseudocode, head is of type List and it points to the first element of the list being passed. Then, pointers are reversed in line 4-8. The return type is a pointer to the reversed list.\newline\newline
 Pseudocode for insitu algorithm that reverses a linked list of
n elements in linear time: 
\begin{algorithm}
\caption{reverseList(List head)} \label{euclid}
\begin{algorithmic}[1]
\State prev $\gets$ NULL
\State current $\gets$ head
\State next $\gets$ NULL
\While { (current $ != $ NULL)}
\State next $\gets$ current.next
\State current.next $\gets$ prev
\State prev $\gets$ current
\State current $\gets$ next
\EndWhile
\State \Return prev
\end{algorithmic} 
\end{algorithm}\newline
It is an insitu algorithm because it just uses 3 pointers and doesn't create a new List and the pointers occupy constant memory, and it doesn't depend on the size of the list. \newline
Time complexity is linear as every operation inside the while loop has constant time complexity, and the while loop runs n times. Hence, the time complexity becomes linear. \newpage
b. \textit{ Code Files: \newline 
         Test code: 7.2b.cpp\newline
         Implementation code: DefImp.cpp\newline
         Headers: headers.h} \newline \newline
Time Complexity analysis: \newline
The inorder traversal for this tree occurs from right-root-left. This order is used to construct the linked list. As we need the time complexity to convert BST to LinkedList, I will ignore the time complexity required for initially creating a BST.So the transformation algorithm leads to inorder traversal and pushes the elements in the list (in front). It is trivial that insertion takes $\theta(1)$. For the recursive traversal, time complexity is $\theta(n/2)$ = $\theta(n)$ as it divides the subproblems into 2 halves, each halve having to deal with n/2 elements.  Hence, total time complexity = $\theta(n)$  \newline \newline
c. \textit{ Code in 7.2c.cpp} \newline \newline
Time complexity analysis:\newline \newline
Every time we need to find the mid position, we have to iterate through the list. For worst case, this operation would have time complexity $\theta(n)$. Adding an element at binary search tree requires us to go through the height of the recursion tree which is $lgn$ so time complexity of adding an element is $\theta(lgn)$. While transforming the list to BST, we divide the problems into 2 halves, and use recursion. Mathematically,\newline \newline
$T(n) = 2 T(n/2) + n + lgn $\newline
By recursion tree method, we obtain total time complexity $=\theta(n(n + n lgn)) = \theta(n^2) $ for my implementation. 
\newline \newline \newline \textit{Extra Note: We can imporve this time by using red black tree which has self balancing property and we don't have to iterate through mid position every time while adding element.}  }}
\end{document}
